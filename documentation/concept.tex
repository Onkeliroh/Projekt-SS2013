\section{Concept}

\subsection{Basic Concept}

The basic concept for this project was to create an interface, which is modular and mainly mobile. Like already explained we wanted to create a interface that has more degrees of freedom in terms of the usage than a installation which is bound to a place and therefore mobile. Due to the fact that we decided to use a more powerful server to manage all devices, we reached a certain degree of bounding to a place, while still being mobile. 
So a server - client - structure is a very broad system and maybe to powerful for the target of this project. But in fact we needed a system that is highly expandable to add new features use it in another project.
First idea was to build several independent hardware devices which communicate between each other. But the usage of a server - client based system has plenty more advantages than to build a simple hardware - communication - system:
It is easier to implement new functionalities or to use this environment for later projects. Furthermore an administrator can change the device defaults pretty easy using the Graphical Interface.   

\subsection{Hardware Concept}
Each node in the network has a panstamp: a small board whose core is the ATMEGA 328 P [{\url{http://www.atmel.com/devices/atmega328.aspx}}].
Panstamps can communicate with other devices in a wireless way thanks to the transceiver CC1101. 



Each sensor node has an accelerometer, which senses the acceleration experimented by an entity in each of the cardinal directions (x,y and z).
On the sensor node board there is a circuit that monitors the voltage of the battery.
 
The LiPo battery should not be over-discharged for this reduces its life.
 
 
 

%schematic of the battery monitor circuit
%overall schematic of a sensor node
%schematic of a actuator node
%architecture diagramm - physical layer
%architecture diagramm - software layer
%packets structure

\subsection{Software Concept} 

To achieve the degree of mobility, the server only needs a connected panstamp to work properly. It is also possible to put the server software on a more powerful microcontroller like a raspberry pi or some similar controller.
The modularity is given through a number of easy configurable files. Changing behavior, appearance or the defined actions is pretty easy to do.

The system contains the different hardware devices and the server. The communication is enabled by using panstamps. When one of the devices gets activated by e.g. kicking it, the accelerometer sensor will trigger an input sending it to the panstamp. There a packet will be created which contains the ID of the device, the intensity of the kinetic input and a checksum bit at the end.
The kinetic inputs "first contact", "played" and "played hard" are triggered by each other:
So when the device gets kicked, his state will change from "standby" to "first contact", then when the threshold is high enough, the state changes directly to "played". There cannot be a change from "first contact" to "played hard". 
\newline
\newline
Those data will be send to the panstamp of the server where this data will be analyzed and compared to the corresponding personality of the device. The personality then outputs the behaviour for the device. A behaviour consists two colors (which can be the same) and a pattern. This pattern describes the appearance of the colors. (Like a blinking or fading of the LEDs)
The idea was to create typical characters for the devices. Below you can see the table which describes how a device reacts to kinetic inputs into his environment. So if it is in his default state the device "Paul" is fading blue. By changing input the state will change perhaps to the state "hard played". Those behaviour can be manipulated using the servers graphical interface. The 
\newline
\newline
Using the antennas field  it is possible to identify directly neighboured devices. But the usage of this effect is really not exact, because the antennas must be parallel to each other. So apparently most time when two devices got in contact there won't be a "found neighbour" - message. The devices have to be both in right position. This means that the antennas have to be rightly erected. (The ground has to be on bottom side.)   
So by using this technique the following rules shown in this table can be implemented.
When the servers got from the device panstamp the data with which other device it is confronted, the server looks up in the data of the presetpersonalities.java file and returns the matching pattern. For this use it is necessary to define which personality is more dominant than another.
\newline
\newline
For sure there is no interaction when "Paul" gets in touch with another "Paul" (because there should only be one Paul) but by using the servers settings it is quite easy to do so. There won't be any interaction between the same personalities.
\newline
\newline
So when the server has received the data of its state and his neighbourhood of the sending device it will send a new pattern for the LEDs chain actuator when the situation of the sending device has changed.
When the device hadn't send its data packet for two minutes a warning will pop up in the graphical interface. Apparently this will happen when the device is out of range of the sending area of the panstamp antennas (approximately ~50 metres).
This very functionality is illustrated in the following graphic.
% INSERT GRAPHICAL PICTURE OF FUNCTIONALITY OF THE SERVER-CLIENT-SYSTEM       
 
% used technologies
One of the projects constrains in the beginning was to build something based on the Arduino technology, because there is a lot of open - source code in the internet and it is easy to learn.
Another constraint was to write the servers code in Java. Because the servers environment of this project should be similar to other ancient projects at this chair.
Later, when the work began it was necessary to find a hardware module for the devices which is sending and receiving the data packages to and from the server. Some experiments with XBees indicated that the commuting area is pretty to small to have a good functionality of the system. (In fact the server lost signal already when the Device was just approximately five metres apart.) So the work with the panstamp began.   
 

