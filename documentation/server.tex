\subsection{The Server}
The heard of the communication is the server. It takes most of the information brodcasted by the panStamps\cite{panstamp} and processes them.
Provided the users connected through the interface with a serial port with the server-panstamp pluged in, the server takes the message with help of the rxtx-library\cite{rxtx} on a seperate thread and passes the message, after receiving it, to the parser for processing and deciding.

\subsubsection{The Parser}
The Parser takes messages in form of byte arrays with the length of four bytes. The message size was set fixed, due to a more convinient workflow and to limit the brodcasting overhead to a minimum. 
First the parser checkes whether the length of the package is exactly four bytes and if the last byte, which is supposed to be a checksum summing the byte values of every other byte in the message, matches the checksum calculated by the server. If every think is correct the parser then searches for a known device in the device list of the server, if it found no match, it will create a new device with default settings. Once a device was found or created the parser begins to compare the second byte of the message for matching keys stored by the server. First all system\_keys will be compared. For example if the received message contains a ''52'' as second byte, the parser will then recocnize this as the ''the battery is low'' key and will toggle thei boolean value battery\_low of the device to true. 
If no system key matched with the received one, the parser then checks the reaction keys of the device itself. This check only happens if the device it not currently engaged in a neighborhood relationship with another device and if the time of the last received state changing message lays back a certain time. For this checking and comparing procedure the device owns a map with all reaction keys stored to it and a associated boolean value, representing the choise of ignoring or reacting to the received key. If a appropriate key was found and acording to the boolean value a reaction should happen, then the state of the devices personality will be increased and the new information about the pattern and both colours will be send to the server-panstamp using the rxtx-library.

\subsubsection{Device and Personality Structure}
The server itself and the according class holds a list of all known devices. Every lookup action depends on this list. The device class itself holds a instance of the personality class.
Devices can be seen as a representation of the hardware devices with the two panstamps in them. It refers to the hardware and therefor stores the Id's of the panstamps and timestamps of the last received message either one of the hardware device panstamps, a second timestamp of the last state change and a third timestamp of the last ''neighborhood meeting''. All those information are accesible through ''get'' functions as well as mostly modifiable through ''set'' functions.

The personality class stores information about the states of the personality and the according patterns and colors. This class also provides ''get'' and ''set'' functions to retrieve or change values. Additionaly the personality class stores map object of all known personalities and the appropriate responce in form of pattern and colors to every possible neighbor. If the device and therefor the personality encounter a unknown personality as a neighbor a default responce will be send. 
The neighbor map provides the ability to set reactions to neighbor personality, even if they don't exsist yet.

To get the server and the project running without setting up every single device by hand a enumeration for pre defined personalities was created. One can select between each of those personalities. Once a pre defined personality is selected, the previous personality of the current device will be overwritten. This approach saves time.

\subsubsection{Key Structure}
During the development we thought of keys, single byte values, to represent commands, messages, patterns and colors. To store these keys several enumerations were created to store related keys with their name and value.
We devided the keys in enumerations:
\begin{itemize}
    \item system
    \begin{itemize}
         \item stores basic keys for transmitting status infrmation (e.g. ''low battery'')
    \end{itemize}
    \item color
    \begin{itemize}
        \item stores byte values for every color hardcoded to the actuator panstamp of the hardware device
    \end{itemize}
    \item pattern
    \begin{itemize}
        \item stores byte values for every pattern hardcoded to the actuator panstamp of the hardware device
    \end{itemize}
    \item key
    \begin{itemize}
        \item stores byte values for every possible action happening to the hardware device
    \end{itemize}
\end{itemize} 

Every class or function reffering to those values calls only the enumeration item by its name. The advantage of this aproche is easier changing of single values as well as a quicker overview.
